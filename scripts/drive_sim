#!/usr/bin/env python3

import math
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist, Pose, Point, Quaternion, TransformStamped
from tf2_ros import TransformBroadcaster
from rclpy.task import Future
from safe_scout_simulator.srv import SampleGroundTruth
from visualization_msgs.msg import Marker, MarkerArray



class FullyActuated2DDriveSim(Node):
    def __init__(self):
        super().__init__('fully_actuated_2d_drive_sim')

        # Robot state - will be set from parameters
        self.x = 0.0
        self.y = 0.0
        self.theta = 0.0  # Heading angle (rad)

        # Velocity commands (local frame)
        self.linear_x = 0.0  # Forward/backward velocity
        self.linear_y = 0.0  # Left/right velocity (sideways)
        self.angular_velocity = 0.0  # Rotational velocity

        # Subscriber to cmd_vel
        self.cmd_vel_sub = self.create_subscription(
            Twist,
            'spirit/planner_twist_command',
            self.cmd_vel_callback,
            10
        )

        # Publisher for pose (geometry_msgs/Pose)
        self.pose_pub = self.create_publisher(Pose, 'spirit/current_pose', 10)

        # Publisher for robot marker visualization
        self.robot_marker_publisher = self.create_publisher(MarkerArray, 'spirit/current_pose_marker', 10)

        # TF broadcaster for map -> base_link
        # self.tf_broadcaster = TransformBroadcaster(self)

        # Timer for simulation updates (10 Hz)
        self.timer_period = 0.1  # seconds
        self.timer = self.create_timer(self.timer_period, self.update_pose)

        self.get_logger().info('Drive sim started')

        # --- Initial pose parameters (can be set via ROS params) ---
        self.declare_parameter('initial_x', 0.0)
        self.declare_parameter('initial_y', 0.0)
        self.declare_parameter('initial_theta', 0.0)  # radians
        self.x = float(self.get_parameter('initial_x').value)
        self.y = float(self.get_parameter('initial_y').value)
        self.theta = float(self.get_parameter('initial_theta').value)

        # --- Slip model parameters (can be tuned via ROS params) ---
        self.declare_parameter('wheel_radius', 0.2)
        self.declare_parameter('wheel_width', 0.05)
        self.declare_parameter('clearance_h', 0.0)
        self.declare_parameter('base_mass', 12.0)
        self.declare_parameter('payload_mass', 0.0)
        self.declare_parameter('excitation_frequency', 1.0)  # Hz
        self.wheel_radius = float(self.get_parameter('wheel_radius').value)
        self.wheel_width = float(self.get_parameter('wheel_width').value)
        self.clearance_h = float(self.get_parameter('clearance_h').value)
        self.base_mass = float(self.get_parameter('base_mass').value)
        self.payload_mass = float(self.get_parameter('payload_mass').value)
        self.excitation_frequency = float(self.get_parameter('excitation_frequency').value)
      
        self.sample_client = self.create_client(SampleGroundTruth, 'sample_ground_truth')
        if not self.sample_client.wait_for_service(timeout_sec=3.0):
            self.get_logger().warn('sample_ground_truth service not available yet')
        
        self.get_logger().info(f'Robot initialized at pose: x={self.x:.2f}, y={self.y:.2f}, theta={self.theta:.2f} rad ({math.degrees(self.theta):.1f} deg)')

    def cmd_vel_callback(self, msg: Twist):
        """Callback to receive velocity commands in robot's local frame."""
        self.linear_x = msg.linear.x      # Forward/backward
        self.linear_y = msg.linear.y      # Left/right (sideways)
        self.angular_velocity = msg.angular.z  # Rotation

    def update_pose(self):
        """Update the robot pose using fully actuated 2D kinematics."""
        dt = self.timer_period

        # Transform local velocities to global coordinate frame
        # Robot can move in any direction relative to its current orientation
        cos_theta = math.cos(self.theta)
        sin_theta = math.sin(self.theta)
        
        # Compute slip ratio from terrain stiffness sampled at current (x, y)
        slip_ratio = self.compute_slip_ratio(self.x, self.y, dt)

        # Apply slip to commanded local velocities
        effective_linear_x = self.linear_x * slip_ratio
        effective_linear_y = self.linear_y * slip_ratio

        # Global velocities from local velocities (after slip)
        global_vx = effective_linear_x * cos_theta - effective_linear_y * sin_theta
        global_vy = effective_linear_x * sin_theta + effective_linear_y * cos_theta
        
        # Update position and orientation
        self.x += global_vx * dt
        self.y += global_vy * dt
        self.theta += self.angular_velocity * dt

        # Normalize theta to [-pi, pi]
        self.theta = math.atan2(math.sin(self.theta), math.cos(self.theta))

        # Publish the pose
        pose_msg = Pose()
        pose_msg.position = Point(x=self.x, y=self.y, z=0.0)

        # Quaternion from yaw (theta)
        qz = math.sin(self.theta / 2.0)
        qw = math.cos(self.theta / 2.0)
        pose_msg.orientation = Quaternion(x=0.0, y=0.0, z=qz, w=qw)

        self.pose_pub.publish(pose_msg)

        # # Broadcast TF transform (map -> base_link) for Foxglove visualization
        # t = TransformStamped()
        # t.header.stamp = self.get_clock().now().to_msg()
        # t.header.frame_id = "map"
        # t.child_frame_id = "base_link"
        # t.transform.translation.x = self.x
        # t.transform.translation.y = self.y
        # t.transform.translation.z = 0.0
        # t.transform.rotation.x = 0.0
        # t.transform.rotation.y = 0.0
        # t.transform.rotation.z = qz
        # t.transform.rotation.w = qw
        # self.tf_broadcaster.sendTransform(t)

        # Publish robot position marker
        self.publish_robot_position_marker(pose_msg)

        self.get_logger().info(f'Pose: x={self.x:.2f}, y={self.y:.2f}, theta={self.theta:.2f}')

    def compute_slip_ratio(self, x: float, y: float, delta_t: float) -> float:
        """Compute slip ratio [0,1] using terrain-dependent stiffness.

        Uses the provided model:
          k_phi = z_pred * 1e6 * width * R
          d = m * (R * omega / delta_t + g) / (2 * k_phi)
          s = 2 * sqrt(R^2 - (d + h - R)^2), clipped at 0
          noslip_s = 2R
          slip_ratio = s / noslip_s
        """
    
        # Request terrain value at (x, y)
        
        req = SampleGroundTruth.Request()
        req.x = float(x)
        req.y = float(y)
        future: Future = self.sample_client.call_async(req)
        rclpy.spin_until_future_complete(self, future, timeout_sec=0.02)
        if not future.done() or future.result() is None:
            return 1.0
        z_pred = float(future.result().value)
     

        R = self.wheel_radius
        width = self.wheel_width
        h = self.clearance_h
        g = 9.81
        f = self.excitation_frequency
        m = self.base_mass + self.payload_mass

        # Terrain stiffness
        k_phi = z_pred * 1e6 * width * R

        omega = 2.0 * math.pi * f
        d = m * (R * omega / max(delta_t, 1e-3) + g) / (2.0 * k_phi)

        radicand = R * R - (d + h - R) * (d + h - R)
        if radicand <= 0.0:
            s = 0.0
        else:
            s = 2.0 * math.sqrt(radicand)

        noslip_s = 2.0 * R
        slip = 0.0 if noslip_s <= 0.0 else max(0.0, min(1.0, s / noslip_s))
        return slip

    def publish_robot_position_marker(self, pose_msg):
        """Publish rectangle markers showing robot position and orientation.
        
        Publishes two markers in a MarkerArray for synchronization:
        1. Body rectangle (cyan) - main robot body
        2. Head rectangle (yellow) - front indicator to show orientation
        """
        import math
        
        # Get timestamp once for both markers
        timestamp = self.get_clock().now().to_msg()
        
        # Robot body rectangle (cyan)
        body_marker = Marker()
        body_marker.header.frame_id = "map"
        body_marker.header.stamp = timestamp
        body_marker.ns = "robot"
        body_marker.id = 0
        body_marker.type = Marker.CUBE
        body_marker.action = Marker.ADD

        # Set position from pose
        body_marker.pose.position.x = pose_msg.position.x
        body_marker.pose.position.y = pose_msg.position.y
        body_marker.pose.position.z = pose_msg.position.z

        # Set orientation from pose
        body_marker.pose.orientation = pose_msg.orientation

        # Set rectangle size (robot body dimensions)
        body_marker.scale.x = 0.4  # Length (forward/backward)
        body_marker.scale.y = 0.3  # Width (left/right)
        body_marker.scale.z = 0.2  # Height

        # Set color - cyan for simulation robot body
        body_marker.color.r = 0.0
        body_marker.color.g = 1.0
        body_marker.color.b = 1.0
        body_marker.color.a = 1.0

        # Set lifetime (0 means forever)
        body_marker.lifetime.sec = 0
        body_marker.lifetime.nanosec = 0

        # Head/front rectangle (yellow) - positioned at front of robot
        head_marker = Marker()
        head_marker.header.frame_id = "map"
        head_marker.header.stamp = timestamp
        head_marker.ns = "robot"
        head_marker.id = 1
        head_marker.type = Marker.CUBE
        head_marker.action = Marker.ADD

        # Calculate front position offset (half body length forward)
        # Extract yaw from quaternion
        qz = pose_msg.orientation.z
        qw = pose_msg.orientation.w
        yaw = 2.0 * math.atan2(qz, qw)
        
        # Offset forward by half body length + half head length
        offset_distance = 0.14  # half body (0.2) + half head (0.1/2)
        head_marker.pose.position.x = pose_msg.position.x + offset_distance * math.cos(yaw)
        head_marker.pose.position.y = pose_msg.position.y + offset_distance * math.sin(yaw)
        head_marker.pose.position.z = pose_msg.position.z + 0.03

        # Same orientation as body
        head_marker.pose.orientation = pose_msg.orientation

        # Set head rectangle size (smaller than body)
        head_marker.scale.x = 0.1  # Length
        head_marker.scale.y = 0.25  # Width (slightly narrower than body)
        head_marker.scale.z = 0.21  # Height (slightly shorter than body)

        # Set color - yellow for head/front indicator
        head_marker.color.r = 1.0
        head_marker.color.g = 1.0
        head_marker.color.b = 0.0
        head_marker.color.a = 1.0

        # Set lifetime (0 means forever)
        head_marker.lifetime.sec = 0
        head_marker.lifetime.nanosec = 0

        # Publish both markers together in MarkerArray for synchronization
        marker_array = MarkerArray()
        marker_array.markers = [body_marker, head_marker]
        self.robot_marker_publisher.publish(marker_array)



def main(args=None):
    rclpy.init(args=args)
    node = FullyActuated2DDriveSim()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Shutting down Fully Actuated 2D Drive Simulator')
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

